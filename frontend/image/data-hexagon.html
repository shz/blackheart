<!doctype html>
<html>
  <head>
    <style>
    svg polygon {
      transition: all 1s;
      -webkit-transform: none;
    }
    svg polygon.nekkid0 {
      -webkit-transform: translateX(300px) scale(0);
    }
    svg polygon.nekkid1 {
      -webkit-transform: translateY(300px) scale(0);
    }
    svg polygon.nekkid2 {
      -webkit-transform: translateX(-300px) scale(0);
    }
    svg polygon.nekkid3 {
      -webkit-transform: translateY(-300px) scale(0);
    }
    </style>
  </head>
  <body>
    <svg id="svg" xmlns="http://www.w3.org/2000/svg"></svg>
    <script>
      // TODO - Need to base height calculations off of section size
      //        and not triangle size.  Latter only works for zero
      //        triangle padding.

      var make = function(t, attr) {
        var el = document.createElementNS(svg.namespaceURI, t);
        for (var i in attr) if (attr.hasOwnProperty(i))
          el.setAttribute(i, attr[i]);
        return el;
      };

      // Constants
      var svg = document.getElementById('svg');

      // Layout properties
      var edgeCount = 5;
      var triangleWidth = 97;
      var trianglePadding = 0;

      // Calculated layout properties
      var triangleHeight = Math.sqrt(
        -Math.pow(triangleWidth / 2, 2) + Math.pow(triangleWidth, 2)
      );
      // console.log(triangleWidth, triangleHeight);
      var sectionWidth = (edgeCount * triangleWidth) + ((edgeCount - 1) * (trianglePadding * 2));
      var sectionHeight = (edgeCount * triangleHeight) + ((edgeCount - 1) * trianglePadding);
      // console.log(sectionWidth, sectionHeight);

      // Set proper SVG size
      svg.style.width = 2 * sectionWidth + 'px';
      svg.style.height = 2 * sectionHeight + 'px';
      svg.style.WebkitTransform = 'scale(0.5)';

      // Color positions
      var colorPositions = [];
      var r = function() {
        return Math.random();
      };
      for (var i=0; i<4; i++) {
        colorPositions.push([
          r(),
          r(),
          [r(), r(), r()]
        ]);
      }
      for (var i=0; i<r() * 4; i++)
        colorPositions.push([r(), r(), [1, 1, 1]]);
      // var colorPositions = [
      //   [0.25, 0.25, [0, 0, 0]],
      //   [0.25, 0.75, [1, 0, 0]],
      //   [0.75, 0.25, [0, 0, 1]],
      //   [0.75, 0.75, [0, 1, 0]],
      //   [0.50, 0.50, [1, 1, 1]]
      // ];

      // Color state machine, tracks absolute position
      var color = {
        rot: 0,
        getColor: function(x, y) {
          // Normalize inside section
          x = x / (sectionWidth - triangleWidth - trianglePadding);
          y = y / (sectionHeight - triangleHeight - trianglePadding);

          // Adjust coordinate from upper-left to lower-mid
          x = x - 0.5;
          y = 1 - y;

          // Convert to polar
          var d = Math.sqrt(x*x + y*y);
          var r = Math.atan(x / y) || 0;

          // Convert local polar to global polar
          r += (color.rot / 360) * (Math.PI * 2);

          // console.log(r, d);

          // Convert back from polar to cartesian
          x = Math.sin(r) * d;
          y = Math.cos(r) * d;

          // // Normalize from (-1, 1) to (0, 1)
          x = (x + 1) / 2;
          y = (y + 1) / 2;

          // Now that we have absolute positioning, we base our color
          // off of the total distance from the defined colors
          var finalColor = [0, 0, 0];
          var distances = [];
          for (var i=0; i<colorPositions.length; i++) {
            var dx = colorPositions[i][0] - x;
            var dy = colorPositions[i][1] - y;
            var dt = Math.sqrt(dx*dx + dy*dy);
            distances.push(dt);
          }
          for (var i=0; i<distances.length; i++) {
            for (var p=0; p<3; p++) {
              finalColor[p] += Math.pow(1 - distances[i], 3) * colorPositions[i][2][p];
            }
          }

          return 'rgb(' + ((finalColor[0] * 255)|0)
               + ', ' + ((finalColor[1] * 255)|0)
               + ', ' + ((finalColor[2] * 255)|0)
               + ')';

          // Somewhat less lame version
          return 'rgb(0, ' + ((255 * Math.abs(x))|0) + ',' + ((255 * Math.abs(y))|0) + ')';
        }
      };

      // Fills out a section
      var fillSection = function(r, c, x, y) {

        // Do a single row
        for (var i=0; i<c; i++) {
          // Triangle top-left point
          var tx = x + (i * trianglePadding * 2) + (i * triangleWidth);

          // Make bottom-pointing triangle
          var points = [
            [tx, y].join(','),
            [tx + triangleWidth, y].join(','),
            [tx + triangleWidth / 2, y + triangleHeight].join(',')
          ];
          r.appendChild(make('polygon', {
            'fill': color.getColor(tx, y),
            'points': points.join(' ')
          }));

          // Make top-pointing triangle
          if (i > 0) {
            points = [
              [tx - trianglePadding, y].join(','),
              [tx + triangleWidth / 2 - trianglePadding, y + triangleHeight].join(','),
              [tx - triangleWidth / 2 - trianglePadding, y + triangleHeight].join(',')
            ];
            r.appendChild(make('polygon', {
              'fill': color.getColor(tx + triangleWidth / 2, y + triangleHeight / 2),
              'points': points.join(' ')
            }));
          }
        }

        // Keep recursing down if there was more than 1 triangle to draw
        if (c > 1) {
          fillSection(r, c-1,
            x + (triangleWidth / 2) + (trianglePadding),
            y + triangleHeight + trianglePadding
          );
        }
      };

      // Build in sections
      for (var i=0; i<6; i++) {

        // Update the color SM's rotation info
        color.rot = i * 60;

        // Root section element
        var section = make('g', {
          'class': 'section',
          'transform': 'translate(' + sectionWidth + ', ' + sectionHeight + ') '
                     + 'rotate(' + (i * 60) + ')'
                     + 'translate(' + (sectionWidth / -2) + ', -' + (sectionHeight + trianglePadding) + ')'
                     ,
          'width': sectionWidth,
          'height': sectionHeight
        });
        svg.appendChild(section);

        // Fill out the interior triangles
        fillSection(section, edgeCount, 0, 0);
      }

      // Util
      var shuffle = function(o) {
        for(var j, x, i = o.length; i; j = parseInt(Math.random() * i), x = o[--i], o[i] = o[j], o[j] = x);
        return o;
      };

      // Trigger animation
      var polygons = Array.prototype.slice.call(document.querySelectorAll('svg polygon'));
      polygons = shuffle(polygons);
      var dir = '0';
      for (var i=0; i<polygons.length; i++) {
        polygons[i].setAttribute('class', 'nekkid' + dir);
        if (++dir > 3)
          dir = 0;
        setTimeout((function(i) { return function() {
          polygons[i].setAttribute('class', '');
        }})(i), i * 10);
      }
      svg.offsetLeft;
    </script>
  </body>
</html>
